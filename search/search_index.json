{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Writing Portfolio","text":"<p>My first job was at 13 writing about rodeos and stick horse races, and I haven't stopped writing since. From journalism to academia to software documentation, I'm skilled in addressing multiple audiences, in multiple ways, using multiple technical skills and tools.</p> <p></p> <p>I am currently the Staff Technical Writer for SaaS documentation at SailPoint Technologies in Austin, TX. I'm a vocal advocate for centering users' needs in product and doc decisions. I love a technical challenge and specialize in setting up docs-as-code systems and information architectures. I'm also passionate about mentoring, both at work and with volunteer organizations.</p> <p>In addition to my writing experience, I excel at project development and cross-functional collaboration. In 2024 I successfully launched a documentation feedback system that added feedback options to 7,500 documentation pages, resulting in greater customer reach and engagement, substantial documentation improvement, and reduced support tickets. I presented the results and lessons from that system at Write the Docs and in a Document360 webinar.</p> <p>In my free time, I enjoy traveling, playing video games, cooking, mentoring youth, and learning new technologies.</p>"},{"location":"#write-the-docs-2025-presentation","title":"Write the Docs 2025 Presentation","text":"<p>In May 2025, I spoke at Write the Docs Portland. My speech was titled Quest for the Holy Grail: Turning User Feedback Into Meaningful Change.</p> Expand to view abstract <p>Quest for the Holy Grail: Turning User Feedback into Meaningful Change</p> <p>One of the most frustrating experiences as a tech writer is hearing secondhand that a customer complained about the documentation\u2014especially when it\u2019s a nebulous complaint that leaves no clear path for improvement. Receiving quality user feedback is often seen as the Holy Grail of documentation: elusive, invaluable, and transformative. Yet, gathering relevant, actionable insights is an ongoing challenge.</p> <p>In June 2024, SailPoint embarked on a journey to address this challenge by adding a mechanism for users to provide feedback directly on our documentation pages.</p> <p>While implementing a comment option isn\u2019t groundbreaking, this presentation will focus on what we discovered during our quest: the lessons about our value as tech writers, the priorities we identified in gathering user feedback, and how user engagement can drive meaningful improvements in both documentation and the product itself.</p> <p>Key takeaways include:</p> <ul> <li>Building a Feedback System That Works: Learn the essential components needed to ensure your feedback mechanism encourages constructive input instead of becoming a pile of complaints.</li> <li>Making Connections: Discover how fostering cross-functional teamwork and community building enhances the feedback-gathering process.</li> <li>Adapting to Your Team\u2019s Realities: Learn strategies for tailoring your feedback approach to fit your team\u2019s constraints without sacrificing impact.</li> <li>Amplifying User Voices: Understand how to ensure the right stakeholders hear and act on user concerns.</li> <li>Demonstrating Your Value: Gain insights into showcasing how tech writers\u2019 proximity to users strengthens product development.</li> </ul> <p>This talk is designed for anyone seeking to prioritize user feedback effectively and transform customer responses into actionable insights that elevate both documentation and the product experience.</p>"},{"location":"#document360-webinar","title":"Document360 Webinar","text":"<p>View my webinar with Document360 titled Feedback as a Feature: Embedding User Insight into Your Documentation Process.</p>"},{"location":"#writing-samples","title":"Writing Samples","text":"<p>You can view samples of my writing from:</p> <ul> <li>Actively maintained Identity Security public documentation from SailPoint Technologies</li> <li>Anaconda, the Python package distributor</li> <li>CS Disco, a legaltech startup</li> <li>Southwestern University as a professor</li> <li>Northwestern University Graduate School as a student</li> </ul>"},{"location":"academic/","title":"Academic Writing Samples","text":""},{"location":"academic/#as-a-professor","title":"As a professor","text":"<p>I taught three Communication Studies courses at Southwestern University in Georgetown, TX in 2015 - 2016.</p> <ul> <li> <p> Public Speaking and Civic Engagement Syllabus</p> </li> <li> <p> Business and Professional Speaking Syllabus</p> </li> <li> <p> Communication, Culture, and Social Justice Syllabus</p> </li> </ul>"},{"location":"academic/#as-a-student","title":"As a student","text":"<p>I earned my M.A. in Rhetoric and Public Culture from Northwestern University in 2012.</p> <p>I wrote and edited over 250 pages of content in that time, including The Invisible American Family post featured on Professor Robert Hariman's blog on photography and social justice.</p> <ul> <li> The Invisible American Family</li> </ul>"},{"location":"disco/","title":"Legaltech Writing Samples","text":"<p>One of my first technical writing roles was with the legaltech startup CS Disco. I primarily handled internal and process documentation. I've added a PDF of one of my external publications.</p> <ul> <li> Uploading Files to Disco</li> </ul>"},{"location":"id_security/","title":"Identity Security Writing Samples","text":"<p>I created, implemented, and maintain the docs-as-code setup for SailPoint Technologies, which included training 13+ writers to use the custom stack to create and publish 11+ websites.</p> <p>I additionally manage the documentation for multiple identity security and access governance products for SailPoint Technologies, including:</p> <ul> <li> <p>SailPoint AI Application Onboarding</p> </li> <li> <p>SailPoint Cloud Infrastructure Entitlement Management (CIEM)</p> </li> <li> <p>Password Management</p> </li> <li> <p>Cloud Access Management</p> </li> <li> <p>Source Configuration and Management</p> </li> </ul>"},{"location":"anaconda/","title":"Anaconda Writing Samples","text":"<p>I was a tech writer at Anaconda, the open-source Python distributor, from 2018 - 2020. I maintained two help websites, conda and conda-build. This included working with the open-source community and internal stakeholders to add and improve content, as well as learning basic Python and yaml code.</p> <p>The help docs were originally generated using ReStructured Text, VS Code, Sphinx, and a CI/CD pipeline, but have been converted to Markdown for this portfolio.</p> <p>A few examples from my time at Anaconda include:</p> <ul> <li>Conda-build recipes</li> <li>Building skeleton packages</li> <li>Building conda packages</li> <li>Building conda packages from scratch</li> <li>Using conda with Travis CI</li> </ul>"},{"location":"anaconda/build-pkgs-skeleton/","title":"Building conda packages with conda skeleton","text":"<p>This tutorial describes how to quickly build a conda package for a Python module that is already available on PyPI.</p> <p>In the first procedure, building a simple package, you build a package that can be installed in any conda environment of the same Python version as your root environment. The remaining optional procedures describe how to build packages for other Python versions and other architectures, as well as how to upload packages to your Anaconda.org account.</p> <p>Note</p> <p>You may consider using Docker to run the tutorial.</p>"},{"location":"anaconda/build-pkgs-skeleton/#who-is-this-for","title":"Who is this for?","text":"<p>This tutorial is for Windows, macOS, and Linux users who wish to build a conda package from a PyPI package. No prior knowledge of conda-build or conda recipes is required.</p>"},{"location":"anaconda/build-pkgs-skeleton/#building-a-simple-package-with-conda-skeleton-pypi","title":"Building a simple package with conda skeleton pypi","text":"<p>It is easy to build a skeleton recipe for any Python package that is hosted on PyPI, the official third-party software repository for the Python programming language.</p> <p>The <code>conda skeleton</code> command picks up the PyPI package metadata and prepares the conda-build recipe. The final step is to build the package itself and install it into your conda environment.</p> <p>In this section you are going to use conda skeleton to generate a conda recipe, which informs conda-build where the source files are located and how to build and install the package.</p> <p>You'll be working with a package named Click that is hosted on PyPI. Click is a tool for exposing Python functions to create command line interfaces.</p> <ol> <li> <p>In your user home directory, run the <code>conda skeleton</code> command:</p> <pre><code>conda skeleton pypi click\n</code></pre> <p>The two arguments to <code>conda skeleton</code> are the hosting location, in this case <code>pypi</code>, and the name of the package.</p> <p>This creates a directory named <code>click</code> and creates one skeleton file in that directory: <code>meta.yaml</code>. Many other files can be added there as necessary, such as <code>build.sh</code> and <code>bld.bat</code>, test scripts, or anything else you need to build your software. For simple, pure-Python recipes, these extra files are unnecessary and the build/script section in the meta.yaml is sufficient. </p> </li> <li> <p>Use the <code>ls</code> command on OS X or Linux or the <code>dir</code> command on Windows to verify the meta.yaml was created. </p> <p>Note</p> <p>The meta.yaml file has been populated with information from the PyPI metadata and in many cases will not need to be edited.</p> <p>Files in the folder with meta.yaml are collectively referred to as the \"conda build recipe\":</p> <ul> <li><code>meta.yaml</code>--Contains all the metadata in the recipe. Only the     package name and package version sections are     required--everything else is optional.</li> <li><code>bld.bat</code>--Windows commands to build the package.</li> <li><code>build.sh</code>--macOS and Linux commands to build the package.</li> </ul> </li> <li> <p>Now that you have the conda-build recipe ready, you can use conda build to create the package:</p> <pre><code>conda-build click\n</code></pre> <p>When conda-build is finished, it displays the exact path and filename of the conda package.</p> <p>Windows example file path:</p> <p><code>C:\\Users\\jsmith\\miniconda\\conda-bld\\win-64\\click-7.0-py37_0.tar.bz2</code></p> <p>OS X example file path:</p> <p><code>/Users/jsmith/miniconda/conda-bld/osx-64/click-7.0-py37_0.tar.bz2</code></p> <p>Linux example file path:</p> <p><code>/home/jsmith/miniconda/conda-bld/linux-64/click-7.0-py37_0.tar.bz2</code></p> <p>Note</p> <p>Your path and filename will vary depending on your installation and operating system. Save the path and filename information for the next step.</p> </li> <li> <p>Now you can install your newly built package in your conda environment with the use-local flag:</p> <pre><code>conda install --use-local click\n</code></pre> <p>Notice that Click is coming from the local conda-build channel.</p> <pre><code>(click) 0561:~ jsmith$ conda list\n# packages in environment at /Users/Jsmith/miniconda/envs/click:\n# Name                    Version                   Build  Channel\nca-certificates           2019.1.23                     0 \ncertifi                   2019.3.9                 py37_0 \nclick                     7.0                      py37_0    local\n</code></pre> </li> <li> <p>Now verify that Click installed successfully:</p> <pre><code>conda list\n</code></pre> <p>Scroll through the list until you find Click.</p> </li> </ol> <p>At this point, you now have a conda package for Click that can be installed in any conda environment of the same Python version as your root environment. </p> <p>The remaining optional sections show you how to make packages for other Python versions and other architectures and how to upload them to your Anaconda.org account.</p>"},{"location":"anaconda/build-pkgs-skeleton/#building-for-a-different-python-version","title":"Building for a different Python version","text":"<p>By default, conda-build creates packages for the version of Python installed in the root environment. To build packages for other versions of Python, you use the <code>--python</code> flag followed by a version. For example, to explicitly build a version of the Click package for Python 2.7, use:</p> <pre><code>conda-build --python 2.7 click\n</code></pre> <p>Notice that the file printed at the end of the <code>conda-build</code> output has changed to reflect the requested version of Python. <code>conda install</code> will look in the package directory for the file that matches your current Python version.</p> <p>Windows example file path:</p> <p><code>C:\\Users\\jsmith\\Miniconda\\conda-bld\\win-64\\click-7.0-py27_0.tar.bz2</code></p> <p>OS X example file path:</p> <p><code>/Users/jsmith/miniconda/conda-bld/osx-64/click-7.0-py27_0.tar.bz2</code></p> <p>Linux example file path:</p> <p><code>/home/jsmith/miniconda/conda-bld/linux-64/click-7.0-py27_0.tar.bz2</code></p> <p>Note</p> <p>Your path and filename will vary depending on your installation and operating system. Save the path and filename information for the next task.</p>"},{"location":"anaconda/build-pkgs-skeleton/#converting-conda-package-for-other-platforms","title":"Converting conda package for other platforms","text":"<p>Now that you have built a package for your current platform with conda-build, you can convert it for use on other platforms with the <code>conda convert</code> command. </p> <p>This works only for pure Python packages where there is no compiled code. Conda convert does nothing to change compiled code, it only adapts file paths to take advantage of the fact that Python scripts are mostly platform independent. Conda convert accepts a platform specifier from this and a platform specifier from this list:</p> <ul> <li>osx-64</li> <li>linux-32</li> <li>linux-64</li> <li>win-32</li> <li>win-64</li> <li>all</li> </ul> <p>In the output directory, one folder will be created for each of the one or more platforms you chose, and each folder will contain a .tar.bz2 package file for that platform.</p> <p>Windows:</p> <pre><code>conda convert -f --platform all C:\\Users\\jsmith\\miniconda\\conda-bld\\win-64\\click-7.0-py37_0.tar.bz2\n-o outputdir\\\n</code></pre> <p>macOS and Linux:</p> <pre><code>conda convert --platform all /home/jsmith/miniconda/conda-bld/linux-64/click-7.0-py37_0.tar.bz2\n-o outputdir/\n</code></pre> <p>To use these packages, you need to transfer them to other computers and place them in the correct <code>conda-bld/$ARCH</code> directory for the platform, where <code>$ARCH</code> can be <code>osx-64</code>, <code>linux-32</code>, <code>linux-64</code>, <code>win-32</code>, or <code>win-64</code>.</p> <p>A simpler way is to upload all of the bz2 files to Anaconda.org.</p> <p>If you find yourself needing to use <code>conda convert</code>, you might instead prefer to change your recipe to make your package a \"noarch\" package. Noarch packages run anywhere and do not require <code>conda convert</code>. Some of the ecosystem tools don't yet support noarch packages but, for the most part, noarch packages are a better way to go.</p>"},{"location":"anaconda/build-pkgs-skeleton/#uploading-packages-to-anacondaorg","title":"Uploading packages to Anaconda.org","text":"<p>Anaconda.org is a repository for public or private packages. Uploading to Anaconda.org allows you to easily install your package in any environment with just the <code>conda install</code> command, rather than manually copying or moving the tarball file from one location to another. </p> <p>You can choose to make your files public or private. For more information about Anaconda.org, see the Anaconda.org documentation.</p> <ol> <li>Create a free Anaconda.org account and record your new Anaconda.org     username and password.</li> <li>Run <code>conda install anaconda-client</code> and enter your Anaconda.org     username and password.</li> <li>Log into your Anaconda.org account from your terminal with the     command <code>anaconda login</code>.</li> </ol> <p>Now you can upload the new local packages to Anaconda.org.</p> <p>Windows:</p> <pre><code>anaconda upload C:\\Users\\jsmith\\miniconda\\conda-bld\\win-64\\click-7.0-py37_0.tar.bz2\n</code></pre> <p>macOS and Linux:</p> <pre><code>anaconda upload /home/jsmith/miniconda/conda-bld/linux-64/click-7.0-py37_0.tar.bz2\n</code></pre> <p>Change your path and filename to the exact path and filename you saved in <code>python-versions</code>. Your path and filename will vary depending on your installation and operating system.</p> <p>If you created packages for multiple versions of Python, or used conda convert to make packages for each supported architecture, you must use the <code>anaconda upload</code> command to upload each one. It is considered best practice to create packages for Python versions 2.7, 3.4, and 3.5 along with all of the architectures.</p> <p>Tip</p> <p>If you want to always automatically upload a successful build to Anaconda.org, run: <code>conda config --set anaconda_upload yes</code></p> <p>You can log out of your Anaconda.org account with the command:</p> <p><code>anaconda logout</code></p>"},{"location":"anaconda/build-pkgs-skeleton/#troubleshooting-a-sample-issue","title":"Troubleshooting a sample issue","text":"<p>Conda-build may produce the error message \"Build Package missing.\"</p> <p>To explore this error:</p> <ol> <li> <p>Create a conda skeleton package for skyfield. The <code>conda skeleton</code>     command is:</p> <p><code>conda skeleton pypi skyfield</code></p> <p>This command creates the skyfield conda-build recipe.</p> </li> <li> <p>Run <code>conda-build skyfield</code> and observe that it fails with the     following output:</p> <pre><code>Removing old build environment\nRemoving old work directory\nBUILD START: skyfield-0.8-py35_0\nUsing Anaconda Cloud api site https://api.anaconda.org\nFetching package metadata: ......\nSolving package specifications: .\nError:  Package missing in current osx-64 channels:\n  - sgp4 &gt;=1.4\n</code></pre> </li> </ol> <p>In this example, the conda recipe requires <code>sgp4</code> for the skyfield package. The skyfield recipe was created by <code>conda skeleton</code>. This error means that conda could not find the sgp4 package and install it.</p> <p>Since many PyPI packages depend on other PyPI packages to build or run, the solution is sometimes as simple as using <code>conda skeleton</code> to create a conda recipe for the missing package and then building it:</p> <pre><code>conda skeleton sgp4\nconda build sgp4\n</code></pre> <p>You may also try using the <code>--recursive</code> flag with <code>conda skeleton</code>, but this makes conda recipes for all required packages, even those that are already available to conda install.</p>"},{"location":"anaconda/build-pkgs/","title":"Building conda packages from scratch","text":"<p>This tutorial describes how to build a conda package for Click by writing the required files in the conda build recipe.</p>"},{"location":"anaconda/build-pkgs/#who-is-this-for","title":"Who is this for?","text":"<p>This tutorial is for Windows, macOS, and Linux users who wish to generate a conda package by writing the necessary files. Prior knowledge of conda build and conda recipes is helpful.</p>"},{"location":"anaconda/build-pkgs/#before-you-start","title":"Before you start","text":"<ul> <li>You should have already completed Building skeleton packages</li> </ul>"},{"location":"anaconda/build-pkgs/#editing-the-metayaml-file","title":"Editing the meta.yaml file","text":"<ol> <li> <p>Make a new directory for this tutorial named <code>click</code>, and then     change to the new directory:</p> <pre><code>mkdir click\ncd click\n</code></pre> </li> <li> <p>To create a new <code>meta.yaml</code> file, open your favorite editor. Create     a text file and insert the information shown below. A blank     sample <code>meta.yaml</code> follows the table to make it easier to match up     the information.</p> <p>Note</p> <p>To allow correct sorting and comparison, specify <code>version</code> as a string.</p> name click version \"7.0\" (or latest from click releases) git_rev 6.7  (or latest from click releases) giv_url https://github.com/pallets/click.git imports click home https://github.com/pallets/click license BSD </li> </ol>"},{"location":"anaconda/build-pkgs/#sample-metayaml","title":"Sample meta.yaml","text":"<pre><code>package:\n    name:\n    version:\n\nsource:\n    git_rev:\n    git_url:\n\nrequirements:\n    build:\n    - python\n    - setuptools\n\n    run:\n    - python\n\ntest:\n    imports:\n\nabout:\n    home:\n</code></pre> <p>Save the file in the same <code>click</code> directory as <code>meta.yaml</code>. </p>"},{"location":"anaconda/build-pkgs/#writing-the-build-script-files-buildsh-and-bldbat","title":"Writing the build script files build.sh and bld.bat","text":"<p>Besides <code>meta.yaml</code>, 2 files are required for a build:</p> <ul> <li><code>build.sh</code> Shell script for macOS and Linux.</li> <li><code>bld.bat</code> -Batch file for Windows.</li> </ul> <p>The 2 files <code>build.sh</code> and <code>bld.bat</code> must be in the same directory as your <code>meta.yaml</code> file.</p> <p>This tutorial describes how to make both <code>build.sh</code> and <code>bld.bat</code> so that other users can build the appropriate package for their architecture.</p> <ol> <li> <p>Open a text editor and create a new file named <code>bld.bat</code>. Enter the text exactly as shown:</p> <pre><code>\"%PYTHON%\" setup.py install\nif errorlevel 1 exit 1\n</code></pre> <p>Note</p> <p>In <code>bld.bat</code>, the best practice is to to add <code>if errorlevel 1 exit 1</code> after every command so that if the command fails, the build fails.</p> </li> <li> <p>Save this new file <code>bld.bat</code> to the same directory where you put     your <code>meta.yaml</code> file.</p> </li> <li> <p>Open a text editor and create a new file named <code>build.sh</code>. Enter the     text exactly as shown:</p> <pre><code>$PYTHON setup.py install     # Python command to install the script.\n</code></pre> </li> <li> <p>Save your new <code>build.sh</code> file to the same directory where you put     the <code>meta.yaml</code> file.</p> </li> </ol> <p>You can run <code>build.sh</code> with <code>bash -x -e</code>. The <code>-x</code> makes it echo each command that is run, and the <code>-e</code> makes it exit whenever a command in the script returns nonzero exit status. If you need to revert this in the script, use the <code>set</code> command in <code>build.sh</code>.</p>"},{"location":"anaconda/build-pkgs/#building-and-installing","title":"Building and installing","text":"<p>Now that you have your 3 new build files ready, you are ready to create your new package with conda build and install the package on your local computer.</p> <ol> <li> <p>Run conda build:</p> <pre><code>conda-build click\n</code></pre> <p>If you are already in the click folder, you can type <code>conda build .</code></p> <p>When conda build is finished, it displays the package filename and location. In this case the file is saved to:</p> <pre><code>~/anaconda/conda-bld/linux-64/click-7.0-py37_0.tar.bz2\n</code></pre> <p>Note</p> <p>Save this path and file information for the next task. The exact path and filename will vary depending on your operating system and whether you are using Anaconda or Miniconda. The <code>conda-build</code> command tells you the exact path and filename.</p> </li> <li> <p>Install your newly built program on your local computer by using the     <code>use-local</code> flag:</p> <pre><code>conda install --use-local click\n</code></pre> <p>If there are no error messages, Click installed successfully.</p> </li> </ol>"},{"location":"anaconda/build-pkgs/#converting-a-package-to-use-on-all-platforms","title":"Converting a package to use on all platforms","text":"<p>Now that you have built a package for your current platform with conda build, you can convert it for use on other platforms by using the 2 build files, <code>build.sh</code> and <code>bld.bat</code>.</p> <p>Use the <code>conda convert</code> command with a platform specifier from the list:</p> <ul> <li><code>osx-64</code></li> <li><code>linux-32</code></li> <li><code>linux-64</code></li> <li><code>win-32</code></li> <li><code>win-64</code></li> <li><code>all</code></li> </ul> <p>Example</p> <p>To use the platform specifier <code>all</code>:</p> <pre><code>conda convert --platform all ~/anaconda/conda-bld/linux-64/click-7.0-py37_0.tar.bz2 -o outputdir/\n</code></pre> <p>Note</p> <p>Change your path and filename to the path and filename you saved in Building and installing.</p>"},{"location":"anaconda/build-pkgs/#using-pypi-as-the-source-instead-of-github","title":"Using PyPI as the source instead of GitHub","text":"<p>You can optionally use PyPI or another repository instead of GitHub. There is little difference to conda build between building from Git versus building from a tarball on a repository like PyPI. Because the same source is hosted on PyPI and GitHub, you can easily find a script on PyPI instead of GitHub.</p> <p>Replace this <code>source</code> section:</p> <pre><code>git_rev: v0.6.7\ngit_url: https://github.com/pallets/click.git\n</code></pre> <p>With the following:</p> <pre><code>url: https://files.pythonhosted.org/packages/f8/5c/f60e9d8a1e77005f664b76ff8aeaee5bc05d0a91798afd7f53fc998dbc47/Click-7.0.tar.gz\nsha256: 5b94b49521f6456670fdb30cd82a4eca9412788a93fa6dd6df72c94d5a8ff2d7\n</code></pre> <p>Note</p> <p>The <code>url</code> and <code>sha256</code> are found on the PyPI Click page.</p>"},{"location":"anaconda/build-pkgs/#uploading-new-packages-to-anacondaorg","title":"Uploading new packages to Anaconda.org","text":"<p>After converting your files for use on other platforms, you may choose to upload your files to Anaconda.org, formerly known as binstar.org. It only takes a minute to do if you have a free Anaconda.org account.</p> <ol> <li> <p>If you have not done so already, open a free Anaconda.org account     and record your new user name and password.</p> </li> <li> <p>Run the command <code>conda install anaconda-client</code>, and then enter your     Anaconda.org username and password.</p> </li> <li> <p>Log into your Anaconda.org account with the     command:</p> <pre><code>anaconda login\n</code></pre> </li> <li> <p>Upload your package to Anaconda.org:</p> <pre><code>anaconda upload ~/miniconda/conda-bld/linux-64/click-7.0-py37_0.tar.bz2\n</code></pre> <p>Note</p> <p>Change your path and filename to the path and filename you saved in Building and installing</p> <p>Tip</p> <p>To save time, you can set conda to always upload a successful build to Anaconda.org with the command: <code>conda config --set anaconda_upload yes</code>.</p> </li> </ol>"},{"location":"anaconda/building-conda-packages/","title":"Building conda packages","text":"<p>This tutorial describes how to use conda build to create conda packages on Windows, Linux, and Mac operating systems using the examples of SEP and GDAL. Additional Windows-specific instructions are provided in the <code>toolkit</code> section.</p> <p>The final built packages from this tutorial are available on Anaconda Cloud:</p> <ul> <li>SEP</li> <li>GDAL</li> </ul> <p>This tutorial also describes writing recipes. You can see the final SEP recipe and the GDAL recipe on GitHub in the conda documentation repository.</p>"},{"location":"anaconda/building-conda-packages/#who-is-this-for","title":"Who is this for?","text":"<p>This tutorial is for Windows, macOS, and Linux users who wish to build more complex conda packages. This tutorial will involve building scientific packages, which require compilers for several different Python versions.</p>"},{"location":"anaconda/building-conda-packages/#before-you-start4","title":"Before you start","text":"<p>Before you start, make sure you have installed:</p> <ul> <li>conda</li> <li>conda build</li> <li>any compilers you want</li> </ul>"},{"location":"anaconda/building-conda-packages/#toolkit","title":"Toolkit","text":""},{"location":"anaconda/building-conda-packages/#microsoft-visual-studio","title":"Microsoft Visual Studio","text":"<p>In the standard practices of the conda developers, conda packages for different versions of Python are each built with their own version of Visual Studio (VS):</p> <ul> <li>Python 2.7 packages with Visual Studio 2008</li> <li>Python 3.4 packages with VS 2010</li> <li>Python 3.5 packages with VS 2015, (default) 2017</li> <li>Python 3.6 packages with VS 2015, (default) 2017</li> <li>Python 3.7 packages with VS 2015, (default) 2017</li> </ul> <p>Using these versions of VS to build packages for each of these versions of Python is also the practice used for the official python.org builds of Python. Currently VS 2008 and VS 2010 are available only through resellers, while VS 2015 and VS 2017 can be purchased online from Microsoft. Note there is also a community edition of VS 2015 and VS 2017 which may be used.</p>"},{"location":"anaconda/building-conda-packages/#alternatives-to-microsoft-visual-studio","title":"Alternatives to Microsoft Visual Studio","text":"<p>There are free alternatives available for each version of the VS compilers:</p> <ul> <li>Instead of VS 2008, it is often possible to substitute the free     Microsoft Visual C++ Compiler for Python     2.7.</li> <li>Instead of VS 2010, it is often possible to substitute the free     Microsoft Windows SDK for Windows 7 and .NET Framework     4.</li> <li>Make sure that you also install VS 2010 Service Pack 1     (SP1).</li> <li>Due to a bug in the VS 2010 SP1 installer, the compiler tools may be     removed during installation of VS 2010 SP1. They can be restored as     described in Microsoft Visual C++ 2010 Service Pack 1 Compiler     Update for the Windows SDK     7.1.</li> <li>Visual Studio 2015 has a full-featured, free Community     edition     for academic research, open source projects and certain other use     cases.</li> </ul> <p>The MS Visual C++ Compiler for Python 2.7 and the Microsoft Windows SDK for Windows 7 and .NET Framework 4 are both reasonably well tested. Conda build is carefully tested to support these configurations, but there are known issues with the CMake build tool and these free VS 2008 and 2010 alternatives. In these cases, you should prefer the \"NMake Makefile\" generator, rather than a Visual Studio solution generator.</p>"},{"location":"anaconda/building-conda-packages/#windows-versions","title":"Windows versions","text":"<p>You can use any recent version of Windows. These examples were built on Windows 10.</p>"},{"location":"anaconda/building-conda-packages/#other-tools","title":"Other tools","text":"<p>Some environments initially lack tools such as patch or Git that may be needed for some build workflows.</p> <p>On Windows these can be installed with conda:</p> <p><code>conda install git m2-patch</code></p> <p>On macOS and Linux replace <code>m2-patch</code> with <code>patch</code></p>"},{"location":"anaconda/building-conda-packages/#developing-a-build-strategy","title":"Developing a build strategy","text":"<p>Conda recipes are typically built with a trial-and-error method. Often the first attempt to build a package fails with compiler or linker errors, often caused by missing dependencies. The person writing the recipe then examines these errors and modifies the recipe to include the missing dependencies, usually as part of the <code>meta.yaml</code> file. Then the recipe writer attempts the build again and, after a few of these cycles of trial and error, the package builds successfully.</p>"},{"location":"anaconda/building-conda-packages/#building-with-a-python-version-different-from-your-miniconda-installation","title":"Building with a Python version different from your Miniconda installation","text":"<p>Miniconda2 and Miniconda3 can each build packages for either Python 2 or Python 3 simply by specifying the version you want. Miniconda2 includes only Python 2 and Miniconda3 includes only Python 3.</p> <p>Installing only one makes it easier to keep track of the builds, but it is possible to have both installed on the same system at the same time. If you have both installed, use the <code>where</code> command on Windows, or <code>which</code> command on Linux to see which version comes first on PATH since this is the one you will be using:</p> <pre><code>where python\n</code></pre> <p>To build a package for a Python version other than the one in your Miniconda installation, use the <code>--python</code> option in the <code>conda-build</code> command.</p> <p>Example</p> <p>To build a Python 3.5 package with Miniconda2:</p> <p><code>conda-build recipeDirectory --python=3.5</code></p> <p>Replace <code>recipeDirectory</code> with the name and path of your recipe directory.</p>"},{"location":"anaconda/building-conda-packages/#automated-testing","title":"Automated testing","text":"<p>After the build, if the recipe directory contains a test file named <code>run_test.bat</code> on Windows, or <code>run_test.sh</code> on macOS or Linux, or <code>run_test.py</code> on any platform, the file runs to test the package, and any errors are reported. After seeing \"check the output,\" you can also test if this package was built by using the command:</p> <pre><code>conda build --test &lt;path to package&gt;.tar.bz2\n</code></pre> <p>Note</p> <p>Use the Test section of the <code>meta.yaml</code> file to move data files from the recipe directory to the test directory when the test is run.</p>"},{"location":"anaconda/building-conda-packages/#building-a-sep-package-with-conda-and-python-2-or-3","title":"Building a SEP package with conda and Python 2 or 3","text":"<p>The SEP documentation states that SEP runs on Python 2 and 3, and it depends only on NumPy. Searching for SEP and PyPI shows that there is already a PyPI package for SEP.</p> <p>Because a PyPI package for SEP already exists, the <code>conda skeleton</code> command can make a skeleton or outline of a conda recipe based on the PyPI package. Then the recipe outline can be completed manually and conda can build a conda package from the completed recipe.</p>"},{"location":"anaconda/building-conda-packages/#install-visual-studio","title":"Install Visual Studio","text":"<p>If you have not already done so, install the appropriate version of Visual Studio:</p> <p>For Python 3- Visual Studio 2017:     1.  Choose Custom install.     2.  Under Programming Languages, choose to install Visual C++.</p> <p>For Python 2-Visual Studio 2008:     1.  Choose Custom install.     2.  Choose to install X64 Compilers and Tools.      3.  Install Service Pack.</p>"},{"location":"anaconda/building-conda-packages/#make-a-conda-skeleton-recipe","title":"Make a conda skeleton recipe","text":"<ol> <li> <p>Run the skeleton command:</p> <pre><code>conda skeleton pypi sep\n</code></pre> <p>The <code>skeleton</code> command installs into a newly created directory called <code>sep</code>.</p> </li> <li> <p>Go to the <code>sep</code> directory to view the files:</p> <pre><code>cd sep\n</code></pre> </li> </ol> <p>One skeleton file has been created: <code>meta.yaml</code></p>"},{"location":"anaconda/building-conda-packages/#edit-the-skeleton-files","title":"Edit the skeleton files","text":"<p>For this package, <code>bld.bat</code> and <code>build.sh</code> need no changes. You need to edit the <code>meta.yaml</code> file to add the dependency on NumPy and add an optional test for the built package by importing it.</p> <ol> <li>In the requirements section of the <code>meta.yaml</code> file, add a line that     adds NumPy as a requirement to build the package.</li> <li>Add a second line to list NumPy as a requirement to run the package.</li> <li> <p>Set the NumPy version to the letters <code>x.x</code>.</p> <p>Make sure the new line is aligned with <code>- python</code> on the line above it, so as to ensure proper yaml format.</p> </li> </ol> <p>Example</p> <pre><code>requirements:\nhost:\n    - python\n    - numpy     x.x\n\nrun:\n    - python\n    - numpy     x.x\n</code></pre> <p>Notice that there are two types of requirements, host and run. Host represents packages that need to be specific to the target platform when the target platform is not necessarily the same as the native build platform. Run represents the dependencies that should be installed when the package is installed.</p> <p>Note</p> <p>Using the letters <code>x.x</code> instead of a specific version such as <code>1.11</code> pins NumPy dynamically, so that the actual version of NumPy is taken from the build command. Currently, NumPy is the only package that can be pinned dynamically. Pinning is important for SEP because this package uses NumPy's C API through Cython. That API changes between NumPy versions, so it is important to use the same NumPy version at runtime that was used at build time.</p>"},{"location":"anaconda/building-conda-packages/#add-a-test-for-the-built-package","title":"Add a test for the built package","text":"<p>Adding this optional test will test the package at the end of the build by making sure that the Python statement <code>import sep</code> runs successfully:</p> <p>Add <code>- sep</code>, checking to be sure that the indentation is consistent     with the rest of the file.</p> <p>Example</p> <pre><code>test:\n# Python imports\nimports:\n    - sep\n</code></pre>"},{"location":"anaconda/building-conda-packages/#build-the-package","title":"Build the package","text":"<p>Build the package using the recipe you just created:</p> <pre><code>conda build sep\n</code></pre>"},{"location":"anaconda/building-conda-packages/#check-the-output","title":"Check the output","text":"<p>Check the output to make sure that the build completed successfully.     The output contains the location of the final package file and a     command to upload the package to Anaconda Cloud. The output will     look something like:</p> <pre><code># Automatic uploading is disabled\n# If you want to upload package(s) to anaconda.org later, type:\nanaconda upload /Users/builder/miniconda3/conda-bld/osx-64/sep-1.0.3-np111py36_0.tar.bz2\n# To have conda build upload to anaconda.org automatically, use\n# $ conda config --set anaconda_upload yes\nanaconda_upload is not set.  Not uploading wheels: []\n####################################################################################\nResource usage summary:\nTotal time: 0:00:56.4\nCPU usage: sys=0:00:00.7, user=0:00:07.0\nMaximum memory usage observed: 220.1M\nTotal disk usage observed (not including envs): 3.9K\n####################################################################################\nSource and build intermediates have been left in /Users/builder/miniconda3/conda-bld.\nThere are currently 437 accumulated.\nTo remove them, you can run the ```conda build purge``` command\n</code></pre> <p>If there are any linker or compiler errors, modify the recipe and     build again.</p>"},{"location":"anaconda/building-conda-packages/#building-a-gdal-package-with-conda-and-python-2-or-3","title":"Building a GDAL package with conda and Python 2 or 3","text":"<p>This procedure describes how to build a package with Python 2 or Python 3. Follow the instructions for your preferred version.</p> <p>To begin, install Anaconda or Miniconda and conda build. If you are using a Windows machine, also use conda to install git and the m2-patch.</p> <p><code>conda install git</code></p> <p><code>conda install m2-patch</code></p> <p>Because GDAL includes C and C++, building it on Windows requires Visual Studio. This procedure describes how to build a package with Python 2 or Python 3. Follow the instructions for the version that you want to build with.</p> <p>To build a GDAL package:</p> <ol> <li> <p>Install Visual Studio:</p> <ul> <li>For Python 3, install Visual Studio     2017.     Choose Custom install. Under Programming Languages, select     workloads that come from Visual Studio so you choose the Desktop     Development with C++ and Universal Platform C.</li> <li>For Python 2, install Visual Studio     2008.     Choose Custom install. Choose to install X64 Compilers and     Tools. Install Visual Studio 2008 Service Pack 1.</li> </ul> </li> <li> <p>Install Git. Because the GDAL package sources are retrieved from     GitHub for the build, you must install Git.</p> <p><code>conda install git m2-patch conda-build</code></p> </li> <li> <p>Get gdal-feedstock. For the purpose of this tutorial, we will be     using a recipe from Anaconda.</p> <p><code>git clone https://github.com/AnacondaRecipes/gdal-feedstock.git</code></p> </li> <li> <p>Use conda build to build the gdal-feedstock.</p> <p><code>conda build gdal-feedstock</code></p> </li> <li> <p>Check the output to make sure the build completed successfully. The     output also contains the location of the final package file and a     command to upload the package to Cloud. For this package in     particular, there should be two packages that are output: libgdal and     GDAL.</p> </li> <li> <p>In case of any linker or compiler errors, modify the recipe and run     it again.</p> Closer look at the gdal-feedstock <p>Let's take a better look at what's happening inside the GDAL-feedstock. In particular, what is happening in the <code>meta.yaml</code>.</p> <p>The first interesting bit happens under <code>source</code> in the patches section:</p> <pre><code>patches:\n# BUILT_AS_DYNAMIC_LIB.\n- 0001-windowshdf5.patch\n# Use multiple cores on Windows.\n- 0002-multiprocessor.patch\n# disable 12 bit jpeg on Windows as we aren't using internal jpeg\n- 0003-disable_jpeg12.patch\n</code></pre> <p>This section says that when this package is being built on a Windows platform, apply the following patch files. Notice that the patch files are in the patches directory of the recipe. These patches will only be applied to Windows since the <code># [win]</code> selector is applied to each of the patch entries.</p> <p>In the requirements section, notice how there are both a build and host set of requirements. For this recipe, all the compilers required to build the package are listed in the build requirements.</p> <p>Normally, the requirements section will list out packages required to build the package. GDAL requires CMake on Windows, as well as C compilers. Notice that the C compilers are pulled into the recipe using the syntax <code>{{ compiler('c') }}</code>. Since conda build 3, conda build defines a jinja2 function <code>compiler()</code> to specify compiler packages dynamically. So, using the <code>compiler(\u2018c\u2019)</code> function in a conda recipe will pull in the correct compiler for any build platform.</p> <p>You can see that the compilers used by conda build can be specified using a <code>conda_build_config.yaml</code>.</p> <p>Notice that this package has an <code>outputs</code> section. This section is a list of packages to output as a result of building this package. In this case, the packages libgdal and GDAL will be built. Similar to a normal recipe, the outputs can have build scripts, tests scripts and requirements specified.</p> </li> <li> <p>Build GDAL against some build matrix. We will specify building against Python 3.7 and 3.5 using a conda build config. Add the following to your <code>conda_build_config.yaml</code>.</p> <pre><code>python:\n- 3.7\n- 3.5\n</code></pre> </li> <li> <p>Now you can build GDAL using conda-build: <code>conda build gdal-feedstock</code></p> <p>Or explicitly set the location of the conda build variant matrix: <code>conda build gdal-feedstock --variant-config-file conda_build_config.yaml</code></p> </li> </ol>"},{"location":"anaconda/recipe/","title":"Conda-build recipes","text":"<p>To enable building conda packages, install and update conda and conda-build.</p> <p>Building a conda package requires a recipe. A conda-build recipe is a flat directory that contains the following files:</p> <ul> <li><code>meta.yaml</code> - A file that contains all the metadata in the recipe.     Only <code>package/name</code> and <code>package/version</code> are required.</li> <li><code>build.sh</code> - The script that installs the files for the package on     macOS and Linux. It is executed using the <code>bash</code> command.</li> <li><code>bld.bat</code> - The build script that installs the files for the package     on Windows. It is executed using <code>cmd</code>.</li> <li><code>run_test.[py,pl,sh,bat]</code> - An optional Python test file, a test     script that runs automatically if it is part of the recipe.</li> <li>Optional patches that are applied to the source.</li> <li>Other resources that are not included in the source and cannot be     generated by the build scripts. Examples are icon files, readme     files and build notes.</li> </ul> <p>Tip</p> <p>When you use the conda skeleton <code>skeleton_ref</code> command, the first 3 files, <code>meta.yaml</code>, <code>build.sh</code>, and <code>bld.bat</code>, are automatically generated for you.</p>"},{"location":"anaconda/recipe/#conda-build-process","title":"Conda-build process","text":"<p><code>conda-build</code> performs the following steps:</p> <ol> <li>Reads the metadata.</li> <li>Downloads the source into a cache.</li> <li>Extracts the source into the source directory.</li> <li>Applies any patches.</li> <li>Re-evaluates the metadata, if source is necessary to fill any     metadata values.</li> <li>Creates a build environment and then installs the build dependencies     there.</li> <li>Runs the build script. The current working directory is the source     directory with environment variables set. The build script installs     into the build environment.</li> <li>Performs some necessary post-processing steps, such as shebang and     rpath.</li> <li>Creates a conda package containing all the files in the build     environment that are new from step 5, along with the necessary conda     package metadata.</li> <li>Tests the new conda package if the recipe includes tests:<ol> <li>Deletes the build environment.</li> <li>Creates a test environment with the package and its     dependencies.</li> <li>Runs the test scripts.</li> </ol> </li> </ol> <p>The conda-recipes repo contains example recipes for many conda packages.</p> <p>Caution</p> <p>All recipe files, including <code>meta.yaml</code> and build scripts, are included in the final package archive that is distributed to users. Be careful not to put sensitive information such as passwords into recipes where it could be made public.</p> <p>The conda skeleton <code>skeleton_ref</code> command can help make skeleton recipes for common repositories, such as PyPI.</p>"},{"location":"anaconda/recipe/#deep-dive","title":"Deep dive","text":"<p>Let's take a closer look at how conda-build uses a recipe to create a package.</p>"},{"location":"anaconda/recipe/#templates","title":"Templates","text":"<p>When you build a conda package, conda-build renders the package by reading a template in the meta.yaml. See <code>jinja-templates</code>.</p> <p>Templates are filled in using your conda-build config, which shows the matrix of things to build against. The <code>conda build config</code> determines how many builds it has to do. For example, defining a conda_build_config.yaml of the form and filling it defines a matrix of 4 packages to build:</p> <pre><code>foo:\n    - 1.0\n    - 2.0\nbar:\n    - 1.2.0\n    - 1.4.0\n</code></pre> <p>After this, conda-build determines what the outputs will be. For example, if your <code>conda build config</code> indicates that you want two different versions of Python, conda-build will show you the rendering for each Python version.</p>"},{"location":"anaconda/recipe/#environments","title":"Environments","text":"<p>To build the package, conda-build will make an environment for you and install all of the build and run dependencies in that environment. Conda-build will indicate where you can successfully build the package. The prefix will take the form:</p> <pre><code>&lt;path to conda&gt;/conda-bld/&lt;package name and string&gt;/h_env_placeholder\u2026\n</code></pre> <p>Conda-forge downloads your package source and then builds the conda package in the context of the build environment. For example, you may direct it to download from a Git repo or pull down a tarball from another source. </p> <p>What conda-build puts into a package depends on what you put into the build, host, or run sections. Conda-build will use this information to identify dependencies to link to and identify the run requirements for the package. This allows conda-build to understand what is needed to install the package.</p>"},{"location":"anaconda/recipe/#building","title":"Building","text":"<p>Once the content is downloaded, conda-build runs the build step. The build step runs a script. It can be one that you provided. </p> <p>If you do not define the script section, then you can create a build.sh or a bld.bat file to be run.</p>"},{"location":"anaconda/recipe/#prefix-replacement","title":"Prefix replacement","text":"<p>When the build environment is created, it is in a placeholder prefix. When the package is all bundled up, the prefix is set to a dummy prefix. When conda is ready to install the package, it rewrites the dummy prefix with the correct one.</p>"},{"location":"anaconda/recipe/#testing","title":"Testing","text":"<p>Once a package is built, conda-build will test it. To do this, it creates another environment and installs the conda package. The form of this prefix is:</p> <pre><code>&lt;path to conda&gt;/conda-bld/&lt;package name + string&gt;/_test_env_placeholder\u2026\n</code></pre> <p>At this point, conda-build has all of the info from the meta.yaml about what its runtime dependencies are, so those dependencies are installed as well. This generates a test runner script with a reference to the testing meta.yaml that is created. </p>"},{"location":"anaconda/recipe/#output-metadata","title":"Output metadata","text":"<p>After the package is built and tested, conda-build cleans up the environments created prior and outputs the metadata. The recipe for the package is also added in the output metadata. The metadata directory is on the top level of the tarball in the <code>info</code> directory. The metadata contains information about the dependencies of the package and a list of where all of the files in the package go when it is installed. Conda reads that metadata when it needs to install.</p> <p>Running <code>conda install</code> causes conda to:</p> <ul> <li>reach out to the repo data containing the dependencies,</li> <li>guess the right dependencies,</li> <li>install a list of packages,</li> <li>unpack the tarball to look at the info,</li> <li>verify the file based on metadata in the package, and then</li> <li>go through each file in the package and put it in the right location.</li> </ul>"},{"location":"anaconda/use-conda-with-travis-ci/","title":"Using conda with Travis CI","text":"<p>If you are already using Travis CI, using conda is a preferable alternative to using apt-get and pip to install packages. The Debian repos provided by Travis may not include packages for all versions of Python or may not be updated as quickly. Installing such packages with pip may also be undesirable, as this can take a long time, which can consume a large portion of the 50 minutes that Travis allows for each build. Using conda also lets you test the building of conda recipes on Travis.</p> <p>This page describes how to use conda to test a Python package on Travis CI. However, you can use conda with any language, not just Python.</p>"},{"location":"anaconda/use-conda-with-travis-ci/#the-travisyml-file","title":"The .travis.yml file","text":"<p>The following code sample shows how to modify the <code>.travis.yml</code> file to use Minicond for a project that supports Python 2.7, 3.5, and 3.6:</p> <pre><code>language: python\npython:\n  # We don't actually use the Travis Python, but this keeps it organized.\n  - \"2.7\"\n  - \"3.5\"\n  - \"3.6\"\ninstall:\n  - sudo apt-get update\n  # We do this conditionally because it saves us some downloading if the version is the same.\n  - if [[ \"$TRAVIS_PYTHON_VERSION\" == \"2.7\" ]]; then\n      wget https://repo.continuum.io/miniconda/Miniconda2-latest-Linux-x86_64.sh -O miniconda.sh;\n    else\n      wget https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh -O miniconda.sh;\n    fi\n  - bash miniconda.sh -b -p $HOME/miniconda\n  - source \"$HOME/miniconda/etc/profile.d/conda.sh\"\n  - hash -r\n  - conda config --set always_yes yes --set changeps1 no\n  - conda update -q conda\n  # Useful for debugging any issues with conda\n  - conda info -a\n\n  # Replace dep1 dep2 ... with your dependencies\n  - conda create -q -n test-environment python=$TRAVIS_PYTHON_VERSION dep1 dep2 ...\n  - conda activate test-environment\n  - python setup.py install\n\nscript:\n  # Your test script goes here\n</code></pre> <p>Note</p> <p>For information about the basic configuration for Travis CI, see Building a Python Project.</p>"},{"location":"anaconda/use-conda-with-travis-ci/#supporting-packages-that-do-not-have-official-builds","title":"Supporting packages that do not have official builds","text":"<p>To support a package that does not have official Anaconda build:</p> <ol> <li>Build the package yourself.</li> <li>Add it to an Anaconda.org channel.</li> <li> <p>Add the following line to the install steps in <code>.travis.yml</code> so that     it finds the packages on that channel:</p> <pre><code> - conda config --add channels your_Anaconda_dot_org_username\n</code></pre> </li> </ol> <p>Note</p> <p>Replace <code>your_Anaconda_dot_org_username</code> with your user name.</p>"},{"location":"anaconda/use-conda-with-travis-ci/#building-a-conda-recipe","title":"Building a conda recipe","text":"<p>If you support official conda packages for your project, you may want to use conda-build in Travis, so the building of your recipe is tested as well.</p> <ol> <li>Include the conda recipe in the same directory as your source code.</li> <li> <p>In your <code>.travis.yml</code> file, replace the following line:</p> <pre><code>- python setup.py install\n</code></pre> <p>with these lines:</p> <pre><code>- conda build your-conda-recipe\n- conda install your-package --use-local\n</code></pre> </li> </ol>"},{"location":"anaconda/use-conda-with-travis-ci/#appveyor","title":"AppVeyor","text":"<p>AppVeyor is a continuous build service for Windows built on Azure and is an alternative to using Travis CI with conda.</p> <p>For an example project building conda packages on AppVeyor, see https://github.com/rmcgibbo/python-appveyor-conda-example</p>"},{"location":"anaconda/use-conda-with-travis-ci/#bootstrap-your-environment","title":"Bootstrap your environment","text":"<p>To bootstrap your environment, use the standalone conda approach in your <code>appveyor.yml</code>:</p> <pre><code># Config file for automatic testing at travis-ci.org\n\nlanguage: python\npython:\n  - \"2.7\"\n  - \"3.7\"\n\ninstall:\n  - wget https://repo.anaconda.com/pkgs/misc/conda-execs/conda-latest-linux-64.exe -O conda.exe\n  - chmod +x conda.exe\n  - export CONDA_ALWAYS_YES=1\n  # This is where you put any extra dependencies you may have.\n  - ./conda.exe create -p $HOME/miniconda python=$TRAVIS_PYTHON_VERSION conda conda-build pytest six pytest-cov pytest-mock\n  - export PATH=\"$HOME/miniconda/bin:$PATH\"\n  - hash -r\n  # Install your code here.\nscript:\n  - pytest -v --color=yes --cov=cpr tests\nafter_success:\n  - conda install codecov\n  - codecov\n</code></pre>"}]}